[#gitops-policy-definitions]
= Managing policy definitions with {ocp-short} GitOps (Argo CD)

*Deprecated:* `PlacementRule`

Based on Argo CD, you can use {ocp-short} GitOps to manage policy definitions. To allow this workflow, you must grant {ocp-short} GitOps access for you to create policies on the {acm-short} hub cluster. Complete the following steps to create a `ClusterRole` resource for {ocp-short} GitOps, with access to create, read, update, and delete policies and placements:

. Create a `ClusterRole` from the console. Your `ClusterRole` might resemble the following example:

+
[source,yaml]
----
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: openshift-gitops-policy-admin
rules:
  - verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    apiGroups:
      - policy.open-cluster-management.io
    resources:
      - policies
      - policysets
      - placementbindings
  - verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    apiGroups:
      - apps.open-cluster-management.io
    resources:
      - placementrules
  - verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    apiGroups:
      - cluster.open-cluster-management.io
    resources:
      - placements
      - placements/status
      - placementdecisions
      - placementdecisions/status
----

. Create a `ClusterRoleBinding` object to grant the {ocp-short} GitOps service account access to the `openshift-gitops-policy-admin` `ClusterRole` object. Your `ClusterRoleBinding` might resemble the following example:

+
[source,yaml]
----
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: openshift-gitops-policy-admin
subjects:
  - kind: ServiceAccount
    name: openshift-gitops-argocd-application-controller
    namespace: openshift-gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: openshift-gitops-policy-admin
----

When a {acm-short} policy definition is deployed with {ocp-short} GitOps, a copy of the policy is created in each managed cluster namespace. These copies are called replicated policies. To prevent {ocp-short} GitOps from repeatedly deleting this replicated policy or show that the ArgoCD `Application` is out of sync, the `argocd.argoproj.io/compare-options: IgnoreExtraneous` annotation is automatically set on each replicated policy by the {acm-short} policy framework.

There are labels and annotations used by Argo CD to track objects. For replicated policies to not show up at all in Argo CD, you can set `spec.copyPolicyMetadata` to `false` on the {acm-short} policy definition to disable the Argo CD tracking labels and annotations from being copied to the replicated policy.

[#policy-gen-install-on-openshift-gitops]
== Integrating the Policy Generator with {ocp-short} GitOps (Argo CD)

Based on Argo CD, you can use {ocp-short} GitOps to generate policies by using the Policy Generator through GitOps. Since the Policy Generator does not come preinstalled in the {ocp-short} GitOps container image, some customization must take place. In order to follow along, you must have the {ocp-short} GitOps Operator installed on the {acm-short} hub cluster and be sure to log in to the hub cluster.

For {ocp-short} GitOps to have access to the Policy Generator when you run Kustomize, an Init Container is required to copy the Policy Generator binary from the {acm-short} Application Subscription container image to the {ocp-short} GitOps container. Additionally, {ocp-short} GitOps must be configured to provide the `--enable-alpha-plugins` flag when it runs Kustomize. Complete the following steps:

. Start editing the {ocp-short} GitOps `argocd` object with the following command:

+
[source,bash]
----
oc -n openshift-gitops edit argocd openshift-gitops
----

. Modify the {ocp-short} GitOps `argocd` object to contain the following additional YAML content. When a new major version of {acm-short} is released and you want to update the Policy Generator to a newer version, you need to update the `registry.redhat.io/rhacm2/multicluster-operators-subscription-rhel9` image used by the Init Container to a newer tag. View the following example and replace `<version>` with {product-version} or your desired {acm-short} version:

+
[source,yaml]
----
apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
spec:
  kustomizeBuildOptions: --enable-alpha-plugins
  repo:
    env:
    - name: KUSTOMIZE_PLUGIN_HOME
      value: /etc/kustomize/plugin
    initContainers:
    - args:
      - -c
      - cp /policy-generator/PolicyGenerator-not-fips-compliant /policy-generator-tmp/PolicyGenerator
      command:
      - /bin/bash
      image: registry.redhat.io/rhacm2/multicluster-operators-subscription-rhel9:v<version>
      name: policy-generator-install
      volumeMounts:
      - mountPath: /policy-generator-tmp
        name: policy-generator
    volumeMounts:
    - mountPath: /etc/kustomize/plugin/policy.open-cluster-management.io/v1/policygenerator
      name: policy-generator
    volumes:
    - emptyDir: {}
      name: policy-generator
----
+
*Note:* Alternatively, you can create a `ConfigurationPolicy` resource that contains the `ArgoCD` manifest and template the version to match the version set in the `MulticlusterHub`:

+
[source,yaml]
----
image: '{{ (index (lookup "apps/v1" "Deployment" "open-cluster-management" "multicluster-operators-hub-subscription").spec.template.spec.containers 0).image }}'
----
+
If you want to enable the processing of Helm charts inside of a Kustomize directory before generating policies, set the environment variable `POLICY_GEN_ENABLE_HELM` to `"true"` in the `spec.repo.env` field:

+
[source,yaml]
----
env:
- name: POLICY_GEN_ENABLE_HELM
  value: "true"
----

. Now that {ocp-short} GitOps can use the Policy Generator, {ocp-short} GitOps must be granted access to create policies on the {acm-short} hub cluster. Create the `ClusterRole` resource called `openshift-gitops-policy-admin`, with access to create, read, update, and delete policies and placements. Refer to the ealier `ClusterRole` resource example.

. Create a `ClusterRoleBinding` object to grant the {ocp-short} GitOps service account access to the `openshift-gitops-policy-admin` `ClusterRole`. Your `ClusterRoleBinding` might resemble the following resource:

+
[source,yaml]
----
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: openshift-gitops-policy-admin
subjects:
  - kind: ServiceAccount
    name: openshift-gitops-argocd-application-controller
    namespace: openshift-gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: openshift-gitops-policy-admin
----

[#config-gitops-healthcheck]
== Configuring policy health checks in {ocp-short} GitOps (Argo CD)

To define additional health checks for different resource kinds, configure your `ArgoCD` resource. You can customize status messages for your resource kinds. When you add a health check for a resource, you must add it as a `group` in the `resourceHealthChecks` field. Complete the following steps to define health checks for your resource kinds:

//the example provided in the issue is long. I figure we can split it or just show partial examples of how the YAML would look. Are there any CLI commands that users can run to add the groups? This way we can keep the samples at a minimum

. To add the health checks, edit the {ocp-short} GitOps `ArgoCD` resource with the following command:

+
[source,bash]
----
oc -n openshift-gitops edit argocd openshift-gitops
----

. To add a health check for your `CertificatePolicy` resources, run the following command:

+
[source,bash]
----
need command if it exists
----

. Add a health check for your `ConfigurationPolicy` resource with the following command:

+
[source,bash]
----
same as previous step, only if one exists
----

. To add a health check for your `Policy` resources, run the following command:

+
[source,bash]
----
if a command exists
----

. Verify that the health checks work as expected by viewing the `ArgoCD` resource. Run the following command:

+
[source,bash]
----
is there another way for users to verify that it is working?
----

//reminder, still need to add the what's new entry

[#additional-resource-policy-def]
== Additional resources

* Refer to link:https://argoproj.github.io/argo-cd/[Argo CD] documentation.


